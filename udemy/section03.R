# <22. 벡터를 만들어봅시다>
## 핵심 개념 : combine, sequence, replicate

MyFirstVector <- c(3, 45, 35, 734)
MyFirstVector
# [1]   3  45  35 734

is.numeric(MyFirstVector) #TRUE
is.integer(MyFirstVector) #FALSE
#R은 기본적으로 소수점 없는 숫자도 double 형태로 저장한다.
is.double(MyFirstVector) #TRUE


V2 <- c(3L, 12L, 24L, 0L)
#숫자 뒤에 L을 붙이면 integer 형태로 저장된다.
is.integer(V2) #TRUE
is.double(V2) #FALSE


#문자벡터
V3 <- c("a", "B23", "hello", 7)
V3 #"a"     "B23"   "hello" "7" 
#7도 문자로 저장된다.
is.numeric(V3) #FALSE
is.character(V3) #TRUE


seq() #sequence - like ':' 
rep() #replicate

seq(1,15) 
#1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
1: 15
#1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
#이렇게 같은 결과를 낸다.

seq(1,15,2) #2-step
#1  3  5  7  9 11 13 15

rep(3, 50) #3을 50번 출력 
# 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3

rep("a", 20) #문자 a를 20번 출력

x <- c(80, 20) 
rep(x, 10) #벡터 x를 10번 출력
# 80 20 80 20 80 20 80 20 80 20 80 20 80 20 80 20 80 20 80 20


# <23. []대괄호 사용하기>

w <- c("a", "b", "c", "d", "e")
w #이 w벡터에서 각 요소는 대괄호를 통해 엑세스 할 수 있다.

w[1] #"a"
w[-1] #"b" "c" "d" "e" #첫번째 요소 제외한 나머지를 출력
w[-3] #"a" "b" "d" "e" #세번째 요소 제외한 나머지를 출력

#벡터는 다른 변수에 삽입이 가능하다.
v <- w[-3]
v #"a" "b" "d" "e"

w[1:3] #"a" "b" "c"

#combine 사용해보기
w[c(1, 3, 5)] #"a" "c" "e"
w[c(-2, -4)] #"a" "c" "e"

#여러시도
w[7] #NA
w[0] #character(0)



#<24. 벡터화 연산>
#설명할 것 : 대괄호가 왜 R에서 많이 안쓰이는지

# 다른 프로그래밍 언어는 벡터와 벡터를 각 열별로 더할때, loop부터 써야 한다. 하지만 R에서는 그냥 + 기호만 써도 가능하다.
# 벡터 재활용(recycling of vectors) : 길이가 다른 벡터를 서로 더할 때, 길이가 짧은 벡터를 두번 이어 붙여서 길이를 늘리는 방법이다. 이어 붙인 길이가 긴 벡터의 길이와 다를 때도(즉, 배수관계가 아닐 때도) 실행이 가능하지만 R이 경고한다.


a <- c(50, 34, 111, 7, 24, 631, 20, 4, 7, 21)
b <- c(100, 2, 56, 12, 0, 65, 93, 10, 244, 1)
a -b 
# -50   32   55   -5   24  566  -73   -6 -237   20
a > b
#FALSE  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE

a <- c(50, 34, 111, 7, 24)
b <- c(100, 2, 56, 12, 0, 65, 93, 10, 244, 1)
a+b
# 150  36 167  19  24 115 127 121 251  25

a <- c(50, 34, 111, 7, 24, 631)
b <- c(100, 2, 56, 12, 0, 65, 93, 10, 244, 1)
a+b
# 150  36 167  19  24 696 143  44 355   8
# 경고메시지(들):
#   a + b에서: 두 객체의 길이가 서로 배수관계에 있지 않습니다


#<25. 벡터화 연산의 힘>
x <- rnorm(5)
x
#[1] -0.3229809  0.2233809 -0.1215055  1.5583222  0.4781443


#R-specific programming loop
for(i in x){
  print(i)
}
# [1] -0.3229809
# [1] 0.2233809
# [1] -0.1215055
# [1] 1.558322
# [1] 0.4781443

#첫번째 요소 출력하기. 
print(x[1]) #[1] -0.3229809
#각 요소를 출력하는 작업은 iterate 하기에 loop로 나타낼 수 있음


#programming programming loop
for(j in 1:5){
  print(x[j])
}
# [1] -0.3229809
# [1] 0.2233809
# [1] -0.1215055
# [1] 1.558322
# [1] 0.4781443

#________________________________

N <- 10000000000000
a <- rnorm(N)
b <- rnorm(N)

#Vectorized approach
c <- a * b

#De-vectorized approach
d <- rep(NA, N) #메모리는 할당된 빈 벡터가 생성됨.
for(i in 1:N){
  d[i] <- a[i] * b[i]
}

#결과 : 두 방법 다 같은 결과를 내놓지만,
#Vectorized approach가 코드도 짧고, 시간복잡도도 낮다.
#이렇게 벡터화 작업을 하면 작업 속도가 빨라진다.



# <26. R의 함수>
#? 사용하기
#함수 앞에 ?를 붙이면 함수의 인자, 사례 등을 확인할 수 있다.

?rnorm()
rnorm(1)
rnorm(5, 10, 8) #평균 10, 표준편차 8

?seq()
seq(10, 20, 3)
#length out 기능 : step을 지정하는 대신 벡터의 길이를 정의하게 해준다.
seq(from=10, to=20, length.out=100) 
# [1] 10.00000 10.10101 10.20202 10.30303 10.40404 10.50505
# [7] 10.60606 10.70707 10.80808 10.90909 11.01010 11.11111
# [13] 11.21212 11.31313 11.41414 11.51515 11.61616 11.71717
# [19] 11.81818 11.91919 12.02020 12.12121 12.22222 12.32323
# [25] 12.42424 12.52525 12.62626 12.72727 12.82828 12.92929
# [31] 13.03030 13.13131 13.23232 13.33333 13.43434 13.53535
# [37] 13.63636 13.73737 13.83838 13.93939 14.04040 14.14141
# [43] 14.24242 14.34343 14.44444 14.54545 14.64646 14.74747
# [49] 14.84848 14.94949 15.05051 15.15152 15.25253 15.35354
# [55] 15.45455 15.55556 15.65657 15.75758 15.85859 15.95960
# [61] 16.06061 16.16162 16.26263 16.36364 16.46465 16.56566
# [67] 16.66667 16.76768 16.86869 16.96970 17.07071 17.17172
# [73] 17.27273 17.37374 17.47475 17.57576 17.67677 17.77778
# [79] 17.87879 17.97980 18.08081 18.18182 18.28283 18.38384
# [85] 18.48485 18.58586 18.68687 18.78788 18.88889 18.98990
# [91] 19.09091 19.19192 19.29293 19.39394 19.49495 19.59596
# [97] 19.69697 19.79798 19.89899 20.00000
#이렇게 10과 20 사이에 100개의 숫자로 구성되도록 설정.

x<- c("a", "b", "c")
A<-seq(from=10, to=20, along.with=x) #10 15 20

?rep()
rep(5:6, times=10) #5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6 5 6
rep(5:6, each=10) #5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6

?sqrt
A #10 15 20
sqrt(A) #3.162278 3.872983 4.472136


#<27. R의 패키지>

#그래픽 작업을 위한 패키지인 ggplot2 설치
install.packages("ggplot2")
library(ggplot2) #패키지 활성화 시켜야 쓸 수 있음
head(diamonds)

?qplot()
?ggplot()
?diamonds()

qplot(data=diamonds, carat, price, colour=clarity, facets=.~clarity)
